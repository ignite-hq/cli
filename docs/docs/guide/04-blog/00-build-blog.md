---
sidebar_position: 0
description: Learn module basics by writing and reading blog posts to your chain.
slug: /guide/blog
---

# Build a blog

In this tutorial, we will create a blockchain with a module that allows us to
write and read data from the blockchain. This module will implement the ability
to create and read blog posts, similar to a blogging application. The end user
will be able to submit new blog posts and view a list of existing posts on the
blockchain. This tutorial will guide you through the process of creating and
using this module to interact with the blockchain.

The goal of this tutorial is to provide step-by-step instructions for creating a
feedback loop that allows you to submit data to the blockchain and read that
data back from the blockchain. By the end of this tutorial, you will have
implemented a complete feedback loop and will be able to use it to interact with
the blockchain.

First, create a new `blog` blockchain with Ignite CLI:

```
ignite scaffold chain blog
```

In order to create a blog application that uses a blockchain, we need to define
the requirements for our application. We want the application to store objects
of type `Post` on the blockchain. These objects should have two properties: a
`title` and a `body`.

In addition to storing posts on the blockchain, we also want to provide users
with the ability to perform CRUD (create, read, update, and delete) operations
on these posts. This will allow users to create new posts, read existing posts,
update the contents of existing posts, and delete posts that are no longer
needed.

One of the features of the Ignite CLI is the ability to generate code that
implements basic CRUD functionality. This is accomplished through the use of
scaffolding commands, which can be used to quickly generate the necessary code
for creating, reading, updating, and deleting data in your application.

The Ignite CLI is capable of generating code for data that is stored in
different types of data structures. This includes lists, which are collections
of data indexed by an incrementing integer, maps, which are collections indexed
by a custom key, and singles, which are single instances of data. By using these
different data structures, you can customize your application to fit your
specific needs. For example, if you are building a blog application, you may
want to use a list to store all posts, with each post indexed by an integer.
Alternatively, you could use a map to index each post by its unique title, or a
single to store a single post. The choice of data structure will depend on the
specific requirements of your application.

In addition to the data structure you choose, the Ignite CLI also requires you
to provide the name of the type of data that it will generate code for, as well
as fields that describe the type of data. For example, if you are creating a
blog application, you may want to create a type called "Post" that has fields
for the title and body of the post. The Ignite CLI will use this information to
generate the necessary code for creating, reading, updating, and deleting data
of this type in your application.

```
ignite scaffold list post title body
```

Now that you have used the Ignite CLI to generate code for your application,
let's review what it has created. The Ignite CLI will have generated code for
the data structure and data type that you specified, as well as code for the
basic CRUD operations that are needed to manipulate this data. This code will
provide a solid foundation for your application, and you can customize it
further to fit your specific needs. By reviewing the code generated by the
ignite CLI, you can ensure that it meets your requirements and get a better
understanding of how to build your application using this tool.

The Ignite CLI has generated several files and modifications in the
`proto/blog/blog` directory. These include:

* `post.proto`: This is a protocol buffer file that defines the `Post` type,
  with fields for the `title`, `body`, `id`, and `creator`.
* `tx.proto`: This file has been modified to include three RPCs (remote
  procedure calls): `CreatePost`, `UpdatePost`, and `DeletePost`. Each of these
  RPCs corresponds to a Cosmos SDK message that can be used to perform the
  corresponding CRUD operation on a post.
* `query.proto`: This file has been modified to include two queries: `Post` and
  `PostAll`. The `Post` query can be used to retrieve a single post by its ID,
  while the `PostAll` query can be used to retrieve a paginated list of posts.
* `genesis.proto`: This file has been modified to include posts in the genesis
  state of the module, which defines the initial state of the blockchain when it
  is first started.

The Ignite CLI has also generated several new files in the `x/blog/keeper`
directory that implement the CRUD-specific logic for your application. These
include:

* `msg_server_post.go`: This file implements keeper methods for the
  `CreatePost`, `UpdatePost`, and `DeletePost` messages. These methods are
  called when a corresponding message is processed by the module, and they
  handle the specific logic for each of the CRUD operations.
* `query_post.go`: This file implements the `Post` and `PostAll` queries, which
  are used to retrieve individual posts by ID or a paginated list of posts,
  respectively.
* `post.go`: This file implements the underlying functions that the keeper
  methods depend on. These functions include appending (adding) posts to the
  store, getting individual posts, getting the post count, and other operations
  that are needed to manage the posts in the application.

Overall, these files provide the necessary implementation for the CRUD
functionality of your blog application. They handle the specific logic for each
of the CRUD operations, as well as the underlying functions that these
operations depend on.

Files were created and modified in the `x/blog/types` directory.

* `messages_post.go`: This new file contains Cosmos SDK message constructors and
  associated methods such as `Route()`, `Type()`, `GetSigners()`,
  `GetSignBytes()`, and `ValidateBasic()`.
* `keys.go`: This file was modified to include key prefixes for storing blog
  posts. By using key prefixes, we can ensure that the data for our blog posts
  is kept separate from other types of data in the database, and that it can be
  easily accessed when needed.
* `genesis.go`: This file was modified to define the initial (genesis) state of
  the blog module, as well as the `Validate()` function for validating this
  initial state. This is an important step in setting up our blockchain, as it
  defines the initial data and ensures that it is valid according to the rules
  of our application.
* `codec.go`: This file was modified to register our message types with the
  encoder, allowing them to be properly serialized and deserialized when
  transmitted over the network.

Additionally, `*.pb.go` files were generated from `*.proto` files, and they
contain type definitions for messages, RPCs, and queries used by our
application. These files are automatically generated from the `*.proto` files
using the Protocol Buffers (protobuf) tool, which allows us to define the
structure of our data in a language-agnostic way.

The Ignite CLI has added functionality to the `x/blog/client/cli` directory by
creating and modifying several files.
* `tx_post.go`: This file was created to implement CLI commands for broadcasting
  transactions containing messages for the blog module. These commands allow
  users to easily send messages to the blockchain using the Ignite CLI.
* `query_post.go`: This file was created to implement CLI commands for querying
  the blog module. These commands allow users to retrieve information from the
  blockchain, such as a list of blog posts.
* `tx.go`: This file was modified to add the CLI commands for broadcasting
  transactions to the chain's binary.
* `query.go`: This file was also modified to add the CLI commands for querying
  the chain to the chain's binary.

As you can see, the `ignite scaffold list` command has generated and modified a
number of source code files. These files define the types of messages, logic
that gets executed when a message is processed, and the wiring that connects
everything together. This includes the logic for creating, updating, and
deleting blog posts, as well as the queries needed to retrieve this information.

To see the generated code in action, we will need to start the blockchain. We
can do this by using the `ignite chain serve` command, which will build,
initialize, and start the blockchain for us:

```
ignite chain serve
```

Once the blockchain is running, we can use the binary to interact with it and
see how the code handles creating, updating, and deleting blog posts. We can
also see how it processes and responds to queries. This will give us a better
understanding of how our application works and allow us to test its
functionality.

Here is an example of how to use the binary to create a new blog post on the
blockchain:

```
blogd tx blog create-post "Hello, World!" "This is a blog post" --from alice
```